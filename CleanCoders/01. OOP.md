> 해당 내용은 백명선님의 강의 '[클린 코더스](https://www.youtube.com/playlist?list=PLeQ0NTYUDTmMM71Jn1scbEYdLFHz5ZqFA)'를 보며 정리한 내용입니다.

## Intro

> 돌아가는 코드(기계가 읽는 코드)는 아무나 짤 수 있다.
하지만 사람이 이해할 수 있는 코드는 교육되고 훈련된 소프트 엔지니어만 짤 수 있다.
by. Martin Fowler

우리가 짜는 코드는 사람이 이해할 수 있는 코드인가? 기계만 알아보는 코드인가?

현실은 바쁘니까 TDD, Refactoring, Code Review 없이 개발
이렇게 개발한 프로젝트는 버그를 수정하며 또 다른 버그가 발생한다.

다짜고짜 개발부터 시작하면 처음엔 빨라 보일 수 있지만, 고민하고 설계하며 시작한 프로젝트에 비해 더욱 많은 시간을 버그 수정에 소요하게 된다.


이전 회사에서 이렇게 급하게 프로젝트를 수행한 적이 있었다.
시연용이라 대충 굴러가게만 만들었던 프로젝트였는데 시간에 쫓기다보니 결국 해당 프로젝트에 기능을 추가하고 수정해갔다. 워낙 급했던터라 틈틈이 리팩토링을 할 여력도 없었다.
이 프로젝트는 하나를 수정할 때도 여러 부분을 고쳐야했고, 버그를 수정하며 다른 버그들이 발생하여 힘들었던 기억이 있다.
그저 돌아가기만 하면 그만인 코드를 짜는 것이 추후에 얼마나 큰 비용을 지불해야 하는지 몸소 깨달은 순간이었다.

## Why Clean Code

> SW는 한번 작성되면 최소 10번 이상 읽힌다.
그래서 대충 돌아가게 작성하면 안되고 읽기 편하도록 작성해야한다.

대다수의 개발자는 어떤 업무를 할까?
매번 새로운 코드를 작성하며 개발하는 개발자보다 **이미 작성된 코드를 읽고 수정하고 기능을 추가하는 유지보수성 업무를 하는 개발자가 더 많다**.
그렇다면 개발을 하는데에 있어 더 중요한 것은 무엇일까?
돌아가는 코드를 빨리 만드는 것보다 **잘 읽을 수 있는 코드를 만드는 것이 더욱 중요!!**

## Why OOP
### 절차지향
![](https://velog.velcdn.com/images/shawnhansh/post/3357fae4-9eae-41de-8f2a-eaf3f6697bf3/image.png)

알아야 할 것이 적어 초기 진입이 쉽기 때문에 주로 절차 지향적으로 코드를 짠다.
하지만 모든 프로시저(함수)가 데이터를 공유하기 때문에 데이터에 변경이 생기면 관련된 모든 로직을 하나하나 찾아 수정해주어야 한다.

즉, **유지보수가 쉽지 않다.**

### 객체지향
![](https://velog.velcdn.com/images/shawnhansh/post/fbc7471a-37ca-40ae-95f0-1fbc3dee2e00/image.png)

데이터와 데이터를 사용하는 기능(함수)을 객체에 Wrapping해두고 외부 노출을 최소화한다.(Encapsulation)
데이터의 변경이 해당 객체에만 영향을 미치고 외부에 영향을 미치지 않기 때문에 해당 객체만 수정하면 된다.
응집도가 높고 결합도가 낮다고 표현한다.

즉, **유지보수가 쉽다.**

객체지향적으로 분석하고 설계하기가 쉽지 않다.
이게 어렵다면 절차지향적으로 분석 및 설계를 하고 구현하며 **OOP로 Refactoring**을 하면 된다.
Refactoring을 하지 않고 절차지향적인 구현에서 끝나게 된다면 유지보수가 매우 어려워진다.

## Object / Role / Responsibility

> 객체를 볼 때 데이터로 보지 말고 기능으로 봐야한다.

- 클래스의 이름은 '어떻게'가 아닌 '무엇'으로 정의해야한다.
Ex> ArticleService(X) WriteArticleService(O), JsonRequestParser(X) RequestParser(O)

- Role은 관련된 Responsibility의 집합
Ex> Role : 시스템 사용자(사용자, 비회원 사용자, 운영자 등)
Responsibility : 역할을 만족시키기 위해 시스템에서 제공되는 기능(행위)

- 객체는 역할(Role)을 갖는다.

## 객체지향 설계 과정
요구사항 분석 등 일련의 선행과정이 다 되었을 때 클래스는 어떻게 나눌 것인가?

![](https://velog.velcdn.com/images/shawnhansh/post/1fca6ea7-7899-4540-8adc-af87c3bde990/image.png)

기능, 역할로 눈다.
이 결과를 도출하기 위해 ERD, 클래스 다이어그램등의 과정을 거친다.

FlowController에서 필요한 기능을 메서드를 선언하며 로직을 구현한 것이 아닌, 기능에 따라 FileReader, Encrypter, FileWriter 클래스로 분리시켰다.

![](https://velog.velcdn.com/images/shawnhansh/post/63081f46-b90c-403a-a071-59c88ca40f40/image.png)

이후 객체간 메시지 흐름을 연결한다.

FlowController는 흐름을 제어 하고 기능은 기능별로 분리시킨 클래스에서 구현한다.
장점 : 유닛테스트하기 쉬워진다, 클래스를 인터페이스로 추상화를 하면 추후에 구현체를 교체하기도 용이하다. 비즈니스 로직에는 변경이 적어진다.
ex> FileReader를 DBReader나 NetworkReader 등으로 변경이 필요할 때 쉽다.


이 두 과정을 반복한다.

## Encapsulation

> 내부적으로 어떻게 구현했는지를 감춰 내부의 변화가 외부에 영향을 주지 않아야 한다. - 객체 지향의 기본

### StopWatch 예제

- 절차지향 방식
```java
public class StopWatch {
	public long startTime;	//milli seconds
    public long stopTime;	//milli seconds
    public long startNanoTime;	//nano seconds
    public long stopNanoTime;	//nano seconds
    
    public long getElapseTime() {
    	return stopTime - startTime;
    }
    
    public long getElapsedNanoTime() {
    	return stopNanoTime - startNanoTime;
    }
}
```

필드를 public으로 생성(혹은 private이어도 getter, setter를 생성)
만약 또다른 단위의 결과가 필요하다면 클래스에 새로운 메서드 혹은 필드 생성 필요

- 객체지향 방식
```java 
public class StopWatch {
	private long startTime;
    private long stopTime;
    
    public void start() {
    	startTime = System.nanoTime();
    }
    
    public void stop() {
    	stopTime = System.nanoTime();
    }
    
    public Time getElapsedTime() {
    	return new Time(stopTime - startTime);
    }      
}
```
필드를 private으로 생성
메서드는 기능으로서 존재
단위가 변경되어야 하는 경우에도 클래스 수정 불필요

### Tell, Don't Ask

객체의 데이터를 직접 요청 및 변경하는 것이 아닌 **데이터를 잘 알고 있는 객체에게 기능을 수행시킬 것**.

- 절차지향 방식
``` java
if(member.getExpiredDate().getTime() < System.currentTimeMillis) {
	...
    ...
}
```
ASK(객체에게 객체 내부 데이터를 물어봐서 ask)
객체의 필드 값을 가져와서 직접 비교하는 로직.
추후에 비교 조건이 변경된다면 해당 조건 로직을 모두 찾아서 고쳐야한다.

- 객체지향 방식
```java
if(member.isExpired()) {
	...
    ...
}
```
TELL(객체에게 기능을 명령해서 tell)
객체에게 기능을 수행시켜 답을 얻음.
추후에 조건이 변경된다면 member클래스에서 조건만 바꿔주면 된다.

### Command vs Query

- Command(Tell)
객체 내부 상태를 변경하는 메서드
편이를 위해 어떤 결과를 반환할 수 있다.

- Query(Ask)
객체의 상태에 대한 정보를 제공하는 메서드
객체의 상태를 변경하지 않는다.

이 두메서드가 합쳐져 있으면 안된다.(**CQS**, Command Query Seperation)
또한 상태를 두개 이상 변경하는 것도 좋지 않다.


## Polymorphism(다형성)

> 한 객체가 여러가지(poly) 모습/타입(morph)을 가질 수 있다.

![](https://velog.velcdn.com/images/shawnhansh/post/845a2366-d602-4818-a867-bbe706d78724/image.png)

child 객체는 superType 객체에 담길 수 있다.

### 다형성 구현 방법

- Inherit(extends) - 클래스
- Implements - 인터페이스


> 인터페이스는 왜 쓸까?
implements하면 구현해야할 메서드만 늘어나고, 클래스는 extends하면 super 클래스의 메서드를 호출할 수 있으니 이게 더 재사용성이 좋은게 아닐까?

=> **super 클래스의 기능을 child 클래스가 호출하여 기능을 사용하는 것은 추후 유지보수가 어렵다.**

객체지향에서의 좋은 재사용은 **인터페이스를 통한 재사용**을 말한다.
비즈니스 로직과 크게 관련 없는 로직을 외부에 구현하고 이를 인터페이스를 통해 바라보게 하면, 추후에 구현체를 갈아끼우기 쉽다.

### Spring에서 인터페이스를 써야하는 이유

- 현재 구현체가 하나여도, 나중에 두개 이상이 되지 않으리란 법이 없다.
- 테스트가 쉽다.
- 부가적인 기능 추가가 쉽다(Decorator Design Pattern)
- 비즈니스 로직에서 인터페이스를 사용하면 디테일한 구현체 변경에도 비즈니스 로직은 영향을 받지 않는다.

==> _위 내용은 해당 강의가 끝날 때 쯤 더욱 명확해질 것이라고 하셨다._